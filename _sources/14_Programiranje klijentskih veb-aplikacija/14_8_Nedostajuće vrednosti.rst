Недостајуће вредности
=====================

У претходној лекцији је било прилике да се упознаш са објектима као последњом важном колекцијом података. У тој лекцији је такође било речи о вредности *null* и њеној употреби у имплементацији ситуација које не представљају очекивано понашање програма. Са тим знањем, можда ћеш очекивати да сваки пут када JavaScript ”не уме” да израчуна неку вредност, као резултат ћеш добити вредност *null*.

Међутим, размотри наредни пример кода у којем се декларише нова променљива, али јој се не поставља вредност.


.. code-block:: javascript

    let x;

На први поглед вероватно очекујеш једну од наредне две могуће ситуације:

- Пошто нисмо дефинисали вредност променљиве, JavaScript је имплицитно доделио вредност *null*.
- Само декларација променљиве (дакле, без дефинисања вредности) није дозвољено у језику JavaScript, па ова једноставна наредба резултује неком грешком (на пример, *TypeError*).

Стварност је нешто другачија, што се може видети исписивањем у конзоли вредности променљиве *x*.

.. code-block:: javascript

    console.log(x); // undefined

Вредност *undefined* коју добијаш представља још једну посебну вредност у језику JavaScript. Додатно, та вредност има и свој тип података који се назива "undefined", такође. Штавише, овај тип вредности има тачно једну вредност, што је његова јединствена особина у језику JavaScript.

Вредност *undefined* се, угрубо речено, појављује у израчунавањима у којима унутрашњи механизми језика JavaScript нису способни да произведу смислену вредност, али та израчунавања сама по себи нису илегална (тј. не производе грешке). Тешко је исписати све могуће ситуације које воде до израчунавања вредности *undefined*, али нека најважнија која би требало да запамтиш исписујемо у наставку:

- Декларисање променљиве без дефинисања вредности (овде говоримо о променљивама у ужем смислу; константе морају бити дефинисане у потпуности).
- Приступање елементима низа ван граница (на пример, индексирање низа niz целим бројевима мањим од *0* и већим од *niz.length - 1*).
- Приступање својству објекта које не постоји у том објекту (на пример, индексирање објекта *{ ime: "Милица" }* кључем *"prezime"*).
- Повратне вредности функција без наредбе *return* (више о томе у наредној лекцији).

С обзиром да је вредност *undefined* различитог типа од свих осталих JavaScript вредности, поређење са овом вредношћу ће увек резултовати у *false*, осим када се пореди са другом вредности *undefined*.

.. infonote::

    **Напомена:** Као што знаш, оператор *==* (и његов парњак, оператор *!=*) извршава имплицитне конверзије између вредности различитих типова, тако да поређење помоћу овог оператора између вредности *undefined* и неких других вредности може произвести вредност *true*. Међутим, ово понашање је врло тешко за разумевање јер захтева од тебе да научиш напамет све могуће имплицитне конверзије. Због тога, избегавај коришћење оператора *==* (и *!=*).

Због свега овога, обично је пракса да се избегава коришћење вредности *undefined*, осим када треба да провериш резултате извршавања унутрашњих механизама језика JavaScript. Ако је потребно да нека вредност буде недефинисана, размисли да ли је боље да користиш објекте у случају очекиваног тока извршавања програма, односно, вредност *null* у случају неочекиваног тока извршавања програма. На пример, уместо наредног кода:

.. code-block:: javascript

    let broj = 0;
    let znak;

    if (broj > 0) {
      znak = '+';
    }
    else if (broj < 0) {
      znak = '-';
    }
    else {
      znak = undefined;
    }

    console.log(znak); // undefined

боље је да променљиву znak третираш као објекат, као у наредном коду:

.. code-block:: javascript

    let broj = 0;
    let znak;

    if (broj > 0) {
      znak = { simbol: '+' };
    }
    else if (broj < 0) {
      znak = { simbol: '-' };
    }
    else {
      znak = null;
    }

    console.log(znak); // null

Ово је посебно корисна техника приликом дефинисања функција, што ћеш ускоро и видети у наредној лекцији.

Као што видиш, програмски језик JavaScript обилује зачкољицама које ћеш најлакше савладати пажљивим упознавањем језика и самосталним вежбањем у виду решавања задатака. Због тога, приликом изучавања нових функционалности (као што су *Web API* библиотеке), увек је добро да уз учење користиш документацију уместо да учиш напамет како се која библиотека понаша.
